Assembler: Designed and Implemented by Aryan Ghobadi

What is this assembler for?
___________________________

This assembler is one of the main support software systems used to test the main project, this software has been programmed as a C++ solution which converts MIPS assembly 
language variant files, and converts them into the required machine code, comprehensible for our MIPS processor.

How does it work?
___________________________

-Registers are mapped from strings to integers in a Hashmap data-structure, so ‘$s0’ would map to the integer value 16.

-Data-structure to store and process binary outputs from instructions are bitset <32 >, supporting the size requirements of the MIPS ISA, we instantiate a vector of 32 bit bitsets as we parse line by line and convert each line of assembly into its binary equivalent.

-Method of parsing is defined as using C string functions to define delimiters on MIPS assembly code, specifically commas, spaces and brackets for instructions involving offsets. By generating tokens from these defined delimiters, we can split an instruction such as:

   addiu $s0, $s0, 1
Into:
    'addiu' = tok0
    '$s0' = tok1
    '$s0' = tok2
    '1' = tok3

-Method of constructing functions involves using a generic function for R, I and J type instructions, exploiting their symmetry over each type of instruction and having that function take in parameters like opcode, function code, shift amount, etc, depending on type of instruction and the specific instruction called. We determine which constructor function to call depending on what the value of the first token is, which is always an instruction.

-We assemble the instruction and move line by line until all instructions have been assembled, we then output the contents of the vector of instructions into an output txt file, and for simplification purposes we output the value in hexadecimal.


How does it fit into the testing hierarchy?
________________________________

-The assembler is the crucial intermediary in the test chain. For the initial testing phase, hand-written assembly instructions were written, as well as instructions generated from C programs, the instruction sequences generated/written are passed into the assembler to be assembled. Output files are then passed into the CPU testbench apparatus, where it is compared to a reference or an error code is extracted. Alternatively, we designed simple test programs on C, such as Fibonacci calculation, and used the GCC cross-compiler to compile it into MIPS assembly, where the same test strategy followed.
